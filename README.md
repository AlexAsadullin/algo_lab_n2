## Запуск тестов 

```bash

python3 iterate_through.py
python3 map.py
python3 tree.py
```

## Худшие случаи

### iterate_through.py
N=10000 вложенных прямоугольников вида `{(10*i, 10*i), (10*(2N-i), 10*(2N-i))}`, 1000 точек сгенерированных хэш-функцией вблизи центра `(10*N, 10*N)` с радиусом 5. Все точки попадают в область пересечения почти всех прямоугольников, поэтому для каждой точки алгоритм проходит все N прямоугольников и каждый раз условие попадания выполняется. Это худший случай, максимальное количество проверок и совпадений — O(N*M), где M — число точек.

### map.py
N=500 непересекающихся прямоугольников вида `{(100*i, 100*i), (100*i+50, 100*i+50)}`. Каждый прямоугольник даёт 2 уникальные координаты по x и по y, итого 2N уникальных значений на каждую ось. Размер карты — (2N-1)^2 ячеек, и для каждой ячейки проверяются все N прямоугольников. Это худший случай подготовки O(N^3) — максимальное число уникальных координат при данном N.

### tree.py
N=10000 вложенных прямоугольников (те же данные, что в iterate_through). Точки около центра. При обработке событий по x в центральной области все N прямоугольников активны одновременно. При запросе для каждой точки происходит линейный перебор всех активных интервалов — O(N) на запрос. Это худший случай запроса, максимальное число активных интервалов в точке.

## Выводы

**Алгоритм перебора** (iterate_through.py) — не имеет подготовки (O(1)), но каждый запрос стоит O(N). Выгоден при малом числе прямоугольников или малом числе запросов, когда затраты на предобработку не окупаются.

**Алгоритм на карте** (map.py) — подготовка O(N^3), запрос O(log N). Самая быстрая фаза запросов за счёт прямого доступа по карте с бинарным поиском. Выгоден при малом N и большом числе запросов, когда кубическая подготовка допустима, а логарифмические запросы дают выигрыш.

**Алгоритм на дереве** (tree.py) — подготовка O(N log N), запрос O(log N). Лучший баланс: подготовка значительно быстрее карты, запросы так же быстры. Выгоден при большом N и большом числе запросов — подготовка масштабируется, а запросы остаются логарифмическими.

На наших тестовых данных худший случай достигается за счёт:
- вложенных прямоугольников — максимизируют число совпадений при переборе и число активных интервалов в дереве;
- непересекающихся прямоугольников с уникальными координатами — максимизируют размер карты и время подготовки;
- точек в центре пересечения — каждая точка попадает в максимальное число прямоугольников.